<.header>
  <%= @facebook_dump.name %>
  <:subtitle><%= @facebook_dump.path %></:subtitle>
  <:actions>
    <.link href={~p"/sources/facebook/#{@facebook_dump}/edit"}>
      <.button><.icon name="hero-pencil" /></.button>
    </.link>
  </:actions>
</.header>

<div id="dropzone" class="flex items-center justify-center w-full mt-5">
  <label for="dropzone-file" class="flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 dark:hover:bg-bray-800 dark:bg-gray-700 hover:bg-gray-100 dark:border-gray-600 dark:hover:border-gray-500 dark:hover:bg-gray-600"
    ondrop="upload(event)">
        <div class="flex flex-col items-center justify-center pt-5 pb-6">
            <svg aria-hidden="true" class="w-10 h-10 mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
            <p class="mb-2 text-sm text-gray-500 dark:text-gray-400"><span class="font-semibold">Click to upload</span> or drag and drop</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">SVG, PNG, JPG or GIF (MAX. 800x400px)</p>
        </div>
        <input id="dropzone-file" type="file" multiple class="hidden" />
    </label>
</div>

<div id="uploads"></div>

<.back navigate={~p"/sources"}>Back to sources</.back>

<template id="section-tpl">
  <h2 class="title font-semibold text-xl mt-5"></h2>
  <div></div>
</template>
<template id="folder-tpl">
  <h2 class="text-xl mt-2"><span class="title"></span> (<span class="count">0</span>)</h2>
  <ul class="grid gap-2 p-2 max-h-64 overflow-auto"></ul>
</template>

<template id="photo-tpl">
  <li class="bg-slate-100 rounded border-2 border-slate-200 text-xs align-bottom text-center">
    <img class="object-scale-down h-28 w-full p-1" />
    <h5 class="text-ellipsis overflow-hidden"></h5>
    <p></p>
  </li>
</template>

<template id="file-tpl">
  <li class="bg-slate-100 rounded border-2 border-slate-200 text-xs align-bottom flex flex-row">
    <i class="object-cover h-auto w-12 shrink-0 mt-1 ml-1" />
    <div class="flex flex-col justify-start p-3">
      <h5 class="text-ellipsis overflow-hidden"></h5>
      <p></p>
    </div>
  </li>
</template>

 <script>
   const capitalise = (s) =>
     s.replace(/^[-_]*(.)/, (_, c) => c.toUpperCase())
       .replace(/[-_]+(.)/g, (_, c) => ' ' + c.toUpperCase()),
     el = (id) => document.getElementById(id);

   async function upload(e) {
     const items = e.dataTransfer.items,
       entry = items.length === 1 ? items[0].webkitGetAsEntry() : false;

     if (!entry || !entry.isDirectory || 'messages' !== entry.name) {
       alert("Please drop only the 'messages' folder!");
       return;
     }

     el('dropzone').classList.add('hidden');

     const files = {};

     for await (const e of walkTree(entry)) {
       switch (e.name) {
         case 'inbox':
           for await (const contactDir of walkTree(e)) {
             console.info("Found backup for " + contactDir.name);
             for await (const contactItem of walkTree(contactDir)) {
               contactItem.isDirectory
                 ? addFolder(contactItem, files, contactDir.name)
                 : addLogFile(contactItem, files, contactDir.name)
             }
           }
           break;
         case 'photos':
         case 'stickers_used':
           addFolder(e, files);
           break;
         default:
           console.error("Unhandled top-level item '" + e.name + "'");
       }
     }
   }

   function addLogFile(entry, map, parent) {
     if (!Object.hasOwn(map[parent], 'logs')) {
       addHeader(parent, 'logs');
       map[parent]['logs'] = [];
     }

     map[parent]['logs'].push(entry);
     loadPreviews(parent, 'logs', [entry])
   }

   async function addFolder(entry, map, parent = 'global') {
     if (!Object.hasOwn(map, parent)) {
       addHeader(parent, 'global' === parent ? 'Top-level Files' : parent, true);
       map[parent] = {};
     }

     addHeader(parent, entry.name);

     items = await processEntry(entry);
     map[parent][entry.name] = items;

     loadPreviews(parent, entry.name, items)
   }

   function loadPreviews(parent, dir, items) {
     const parentId = 'uploads_' + parent,
       categoryList = parentId + '_' + dir,
       categoryCount = el('count_' + parent + '_' + dir);

     items.forEach(file => {
       file.file(file => {
         const icon = 'application/json' === file.type ? 'hero-chat-bubble-left-right'
           : file.type.startsWith('audio/') ? 'hero-musical-note' : 'hero-document',
           isImage = file.type.startsWith('image/');

         if (!isImage && 'application/json' !== file.type) {
           el(categoryList).classList.remove('grid', 'grid-cols-3');
         }

         el(categoryList).append(makeTemplate(file, icon, isImage));
       });

       categoryCount.innerText = 1 + parseInt(categoryCount.innerText);
     });
   }

   function addHeader(parent, dir, container = false) {
     const [title, tpl, tag, wrapper, idSuffix] = container ? [
       dir, 'section-tpl', 'div', 'uploads', ''
     ] : [
       capitalise(dir), 'folder-tpl', 'ul', `uploads_${parent}`, `_${dir}`
     ], clone = el(tpl).content.cloneNode(true);

     clone.querySelector('.title').textContent = title;
     clone.querySelector(tag).id =  `uploads_${parent}${idSuffix}`;

     if (!container) {
       clone.querySelector('.count').id = `count_${parent}_${dir}`;
       clone.querySelector(tag).classList.add(
         ['photos', 'stickers_used'].includes(dir) ? 'grid-cols-5' : 'grid-cols-3'
       );
     }

     el(wrapper).append(clone);
   }

   function makeTemplate(file, icon = null, isImage = false) {
     const clone = el(`${isImage ? 'photo' : 'file'}-tpl`).content.cloneNode(true),
       img = clone.querySelector('img'),
       uri = URL.createObjectURL(file);

     clone.querySelector('li').id = `file_${file.name}`;
     clone.querySelector('h5').textContent = file.name;
     clone.querySelector('p').textContent = `${file.size} bytes`;

     if (isImage) {
       clone.querySelector('img').src = uri;
       clone.querySelector('img').onload = () => URL.revokeObjectURL(uri);
     } else {
       clone.querySelector('i').classList.add(icon);
     }

     return clone;
   }

   async function processEntry(entry, items = []) {
     if (entry.isDirectory) {
       for await (const e of walkTree(entry)) {
         await processEntry(e, items)
       }
     } else {
       items.push(entry);
     }

     return items;
   }

   async function* walkTree(dir) {
     const reader = dir.createReader(),
       nextBatch = () => new Promise((resolve, reject) => reader.readEntries(resolve, reject));

     while (true) {
       let entries = await nextBatch();

       if (!entries.length) {
         break;
       }
       for (const entry of entries) {
         yield entry;
       }
     }
   }
 </script>
