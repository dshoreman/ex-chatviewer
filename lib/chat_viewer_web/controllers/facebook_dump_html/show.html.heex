<.header>
  <%= @facebook_dump.name %>
  <:subtitle><%= @facebook_dump.path %></:subtitle>
  <:actions>
    <.link href={~p"/sources/facebook/#{@facebook_dump}/edit"}>
      <.button><.icon name="hero-pencil" /></.button>
    </.link>
  </:actions>
</.header>

<div id="dropzone" class="flex items-center justify-center w-full mt-5">
  <label for="dropzone-file" class="flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 dark:hover:bg-bray-800 dark:bg-gray-700 hover:bg-gray-100 dark:border-gray-600 dark:hover:border-gray-500 dark:hover:bg-gray-600"
    ondrop="handleDrop(event)">
        <div class="flex flex-col items-center justify-center pt-5 pb-6">
            <svg aria-hidden="true" class="w-10 h-10 mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
            <p class="mb-2 text-sm text-gray-500 dark:text-gray-400"><span class="font-semibold">Click to upload</span> or drag and drop</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">SVG, PNG, JPG or GIF (MAX. 800x400px)</p>
        </div>
        <input id="dropzone-file" type="file" multiple class="hidden" />
    </label>
</div>

<div id="uploads" data-uri={~p"/sources/facebook/#{@facebook_dump}/attachments"}></div>

<div id="actions" class="grid place-items-center hidden">
  <button onclick="startUpload()" id="upload-btn" class="middle none center bg-blue-500 font-bold text-white uppercase mt-6 pt-4 pb-3 px-12 shadow-md transition-all hover:shadow-lg focus:opacity-[0.85] active:opacity-[0.85] disabled:pointer-events-none disabled:opacity-50" disabled>Start Upload</button>
</div>

<.back navigate={~p"/sources"}>Back to sources</.back>

<template id="section-tpl">
  <h2 class="title font-semibold text-xl mt-5"></h2>
  <div></div>
</template>
<template id="folder-tpl">
  <h2 class="text-xl mt-2"><span class="title"></span> (<span class="count">0</span>)</h2>
  <ul class="grid gap-2 p-2 max-h-64 overflow-auto"></ul>
</template>

<template id="photo-tpl">
  <li class="bg-slate-100 relative rounded border-2 border-slate-200 text-xs align-bottom text-center">
    <div class="static">
      <div class="absolute h-6 w-6 top-2 right-3 drop-shadow-[1px_1px_1px_rgba(0,0,0,0.5)]">
        <i class="hero-signal progress hidden bg-orange-400 w-full h-full" />
      </div>
    </div>
    <img class="object-scale-down h-28 w-full p-1" />
    <h5 class="text-ellipsis overflow-hidden"></h5>
    <p></p>
  </li>
</template>

<template id="file-tpl">
  <li class="bg-slate-100 rounded border-2 border-slate-200 text-xs align-bottom flex flex-row">
    <i class="object-cover h-auto w-12 shrink-0 mt-1 ml-1" />
    <div class="flex flex-col justify-start p-3">
      <h5 class="text-ellipsis overflow-hidden"></h5>
      <div class="flex-start flex h-1.5 w-full overflow-hidden rounded-sm bg-blue-gray-50 text-xs font-medium">
        <div class="progress flex h-full items-baseline justify-center overflow-hidden break-all bg-pink-500 text-white" style="width: 0%;"></div>
      </div>
      <p></p>
    </div>
  </li>
</template>

 <script>
   const BATCH_SIZE = 5,
     CSRF_TOKEN = document.querySelector('meta[name=csrf-token]').content,
     files = {};

   const capitalise = (s) =>
     s.replace(/^[-_]*(.)/, (_, c) => c.toUpperCase())
       .replace(/[-_]+(.)/g, (_, c) => ' ' + c.toUpperCase()),
     el = (id) => document.getElementById(id);

   async function handleDrop(e) {
     const items = e.dataTransfer.items,
       entry = items.length === 1 ? items[0].webkitGetAsEntry() : false;

     if (!entry || !entry.isDirectory || 'messages' !== entry.name) {
       alert("Please drop only the 'messages' folder!");
       return;
     }

     el('dropzone').classList.add('hidden');
     el('actions').classList.remove('hidden');

     for await (const e of walkTree(entry)) {
       switch (e.name) {
         case 'inbox':
           for await (const contactDir of walkTree(e)) {
             console.info("Found backup for " + contactDir.name);
             for await (const contactItem of walkTree(contactDir)) {
               contactItem.isDirectory
                 ? addFolder(contactItem, files, contactDir.name)
                 : addLogFile(contactItem, files, contactDir.name)
             }
           }
           break;
         case 'photos':
         case 'stickers_used':
           addFolder(e, files);
           break;
         default:
           console.error("Unhandled top-level item '" + e.name + "'");
       }
     }

     el('upload-btn').disabled = false;
   }

   function startUpload() {
     document.querySelectorAll('.progress').forEach((icon) => {
      icon.classList.replace('hidden', 'animate-pulse')
     });

     for (const [contact, sections] of Object.entries(files)) {
       const contactDiv = el(`uploads_${contact}`);

       console.log(`Processing ${Object.keys(sections).length} sections in #uploads_${contact}: `);

       for (const [section, uploads] of Object.entries(sections)) {
         const filesDiv = el(`uploads_${contact}_${section}`),
         batches = Math.ceil(uploads.length / BATCH_SIZE);
         let batch = 1;

         console.log(`   Found ${uploads.length} files in #uploads_${contact}_${section}:`)

         for (let i = 0; i < uploads.length; i += BATCH_SIZE) {
           console.log(`      Uploading batch ${batch} of ${batches}`)
           uploadBatch(contact, section, uploads.slice(i, i + BATCH_SIZE))
           batch++;
         }
       }
     }
   }

   async function uploadBatch(scope, section, filesInBatch) {
     const data = new FormData(),
       parentDiv = el(`uploads_${scope}_${section}`),
       request = new XMLHttpRequest();

     data.set('scope', scope);
     data.set('section', section);

     for (const fe of filesInBatch) {
       let file = await fileFromEntry(fe);

       data.append('files[]', file);
     }

     request.onloadstart = () => {
       for (const fe of filesInBatch) {
         const icon = el(`file_${fe.name}`).querySelector('.progress');

         parentDiv.insertBefore(el(`file_${fe.name}`), parentDiv.firstChild);
         icon.classList.replace('bg-orange-400', 'bg-purple-600');
         icon.classList.replace('animate-pulse', 'animate-spin');
       }
     }

     request.onload = () => {
       let successful = [];

       try {
         ({ files: successful } = JSON.parse(request.response));
       } finally {
         for (const fe of filesInBatch) {
           const css = successful.includes(fe.name)
             ? { bg: 'lime', icon: 'check-circle' }
             : { bg: 'red',  icon: 'exclamation-triangle' },
             icon = el(`file_${fe.name}`).querySelector('.progress');

           icon.classList.remove('animate-spin');
           icon.classList.replace('bg-purple-600', `bg-${css.bg}-400`);
           icon.classList.replace('hero-signal', `hero-${css.icon}`);
           setTimeout(() => parentDiv.append(el(`file_${fe.name}`)), 300);
         }
       }
     };

     request.open('PUT', el('uploads').dataset.uri);
     request.setRequestHeader('X-CSRF-Token', CSRF_TOKEN);
     request.send(data);
   }

   async function fileFromEntry(fe) {
     return new Promise((resolve, reject) => fe.file(resolve, reject));
   }

   function addLogFile(entry, map, parent) {
     if (!Object.hasOwn(map[parent], 'logs')) {
       addHeader(parent, 'logs');
       map[parent]['logs'] = [];
     }

     map[parent]['logs'].push(entry);
     loadPreviews(parent, 'logs', [entry])
   }

   async function addFolder(entry, map, parent = 'global') {
     if (!Object.hasOwn(map, parent)) {
       addHeader(parent, 'global' === parent ? 'Top-level Files' : parent, true);
       map[parent] = {};
     }

     addHeader(parent, entry.name);

     items = await processEntry(entry);
     map[parent][entry.name] = items;

     loadPreviews(parent, entry.name, items)
   }

   function loadPreviews(parent, dir, items) {
     const parentId = 'uploads_' + parent,
       categoryList = parentId + '_' + dir,
       categoryCount = el('count_' + parent + '_' + dir);

     items.forEach(file => {
       file.file(file => {
         const icon = 'application/json' === file.type ? 'hero-chat-bubble-left-right'
           : file.type.startsWith('audio/') ? 'hero-musical-note' : 'hero-document',
           isImage = file.type.startsWith('image/');

         if (!isImage && 'application/json' !== file.type) {
           el(categoryList).classList.remove('grid', 'grid-cols-3');
         }

         el(categoryList).append(makeTemplate(file, icon, isImage));
       });

       categoryCount.innerText = 1 + parseInt(categoryCount.innerText);
     });
   }

   function addHeader(parent, dir, container = false) {
     const [title, tpl, tag, wrapper, idSuffix] = container ? [
       dir, 'section-tpl', 'div', 'uploads', ''
     ] : [
       capitalise(dir), 'folder-tpl', 'ul', `uploads_${parent}`, `_${dir}`
     ], clone = el(tpl).content.cloneNode(true);

     clone.querySelector('.title').textContent = title;
     clone.querySelector(tag).id =  `uploads_${parent}${idSuffix}`;

     if (!container) {
       clone.querySelector('.count').id = `count_${parent}_${dir}`;
       clone.querySelector(tag).classList.add(
         ['photos', 'stickers_used'].includes(dir) ? 'grid-cols-5' : 'grid-cols-3'
       );
     }

     el(wrapper).append(clone);
   }

   function makeTemplate(file, icon = null, isImage = false) {
     const clone = el(`${isImage ? 'photo' : 'file'}-tpl`).content.cloneNode(true),
       img = clone.querySelector('img'),
       uri = URL.createObjectURL(file);

     clone.querySelector('li').id = `file_${file.name}`;
     clone.querySelector('h5').textContent = file.name;
     clone.querySelector('p').textContent = `${file.size} bytes`;

     if (isImage) {
       clone.querySelector('img').src = uri;
       clone.querySelector('img').onload = () => URL.revokeObjectURL(uri);
     } else {
       clone.querySelector('i').classList.add(icon);
     }

     return clone;
   }

   async function processEntry(entry, items = []) {
     if (entry.isDirectory) {
       for await (const e of walkTree(entry)) {
         await processEntry(e, items)
       }
     } else {
       items.push(entry);
     }

     return items;
   }

   async function* walkTree(dir) {
     const reader = dir.createReader(),
       nextBatch = () => new Promise((resolve, reject) => reader.readEntries(resolve, reject));

     while (true) {
       let entries = await nextBatch();

       if (!entries.length) {
         break;
       }
       for (const entry of entries) {
         yield entry;
       }
     }
   }
 </script>
