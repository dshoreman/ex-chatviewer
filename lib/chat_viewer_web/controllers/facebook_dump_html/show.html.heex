<.header>
  <%= @facebook_dump.name %>
  <:subtitle><%= @facebook_dump.path %></:subtitle>
  <:actions>
    <.link href={~p"/sources/facebook/#{@facebook_dump}/edit"}>
      <.button><.icon name="hero-pencil" /></.button>
    </.link>
  </:actions>
</.header>

<div class="flex items-center justify-center w-full mt-5">
  <label for="dropzone-file" class="flex flex-col items-center justify-center w-full h-64 border-2 border-gray-300 border-dashed rounded-lg cursor-pointer bg-gray-50 dark:hover:bg-bray-800 dark:bg-gray-700 hover:bg-gray-100 dark:border-gray-600 dark:hover:border-gray-500 dark:hover:bg-gray-600"
    ondrop="upload(event)">
        <div class="flex flex-col items-center justify-center pt-5 pb-6">
            <svg aria-hidden="true" class="w-10 h-10 mb-3 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"></path></svg>
            <p class="mb-2 text-sm text-gray-500 dark:text-gray-400"><span class="font-semibold">Click to upload</span> or drag and drop</p>
            <p class="text-xs text-gray-500 dark:text-gray-400">SVG, PNG, JPG or GIF (MAX. 800x400px)</p>
        </div>
        <input id="dropzone-file" type="file" multiple class="hidden" />
    </label>
</div>

<div id="uploads"></div>

<.back navigate={~p"/sources"}>Back to sources</.back>

 <script>
   const capitalise = (s) =>
     s.replace(/^[-_]*(.)/, (_, c) => c.toUpperCase())
       .replace(/[-_]+(.)/g, (_, c) => ' ' + c.toUpperCase()),
     el = (id) => document.getElementById(id);

   async function upload(e) {
     const items = e.dataTransfer.items,
       entry = items.length === 1 ? items[0].webkitGetAsEntry() : false;

     if (!entry || !entry.isDirectory || 'messages' !== entry.name) {
       alert("Please drop only the 'messages' folder!");
       return;
     }

     const files = {};

     for await (const e of walkTree(entry)) {
       switch (e.name) {
         case 'inbox':
           for await (const contactDir of walkTree(e)) {
             console.info("Found backup for " + contactDir.name);
             for await (const contactItem of walkTree(contactDir)) {
               contactItem.isDirectory
                 ? addFolder(contactItem, files, contactDir.name)
                 : addLogFile(contactItem, files, contactDir.name)
             }
           }
           break;
         case 'photos':
         case 'stickers_used':
           addFolder(e, files);
           break;
         default:
           console.error("Unhandled top-level item '" + e.name + "'");
       }
     }
   }

   function addLogFile(entry, map, parent) {
     if (!Object.hasOwn(map[parent], 'logs')) {
       addHeader(parent, 'logs');
       map[parent]['logs'] = [];
     }

     map[parent]['logs'].push(entry);
     loadPreviews(parent, 'logs', [entry])
   }

   async function addFolder(entry, map, parent = 'global') {
     if (!Object.hasOwn(map, parent)) {
       addHeader(parent, 'global' === parent ? 'Top-level Files' : parent, true);
       map[parent] = {};
     }

     addHeader(parent, entry.name);

     items = await processEntry(entry);
     map[parent][entry.name] = items;

     loadPreviews(parent, entry.name, items)
   }

   function loadPreviews(parent, dir, items) {
     const parentId = 'uploads_' + parent,
       categoryList = parentId + '_' + dir,
       categoryCount = el('count_' + parent + '_' + dir);

     items.forEach(file => {
       let itemClass = "bg-slate-100 rounded border-2 border-slate-200 text-xs text-ellipsis overflow-hidden"

       el(categoryList).innerHTML += `<li class="${itemClass}">${file.name}</li>`;
       categoryCount.innerText = 1 + parseInt(categoryCount.innerText);
     });
   }

   function addHeader(parent, dir, container = false) {
     const [ title, e, parentDiv, uploadsId, h2Class, uploadsClass ] = container ? [
       dir, 'div', 'uploads', `uploads_${parent}`, 'font-semibold text-xl mt-5', ''
     ] : [
       capitalise(dir) + ` (<span id="count_${parent}_${dir}">0</span>)`, 'ul',
       `uploads_${parent}`, `uploads_${parent}_${dir}`,
       'text-xl mt-2', 'grid grid-cols-3 gap-2 max-h-64 overflow-auto p-2',
     ];

     el(parentDiv).innerHTML += `<h2 class="${h2Class}">${title}</h2>`;
     el(parentDiv).innerHTML += `<${e} id="${uploadsId}" class="${uploadsClass}"></${e}>`;
   }

   async function processEntry(entry, items = []) {
     if (entry.isDirectory) {
       for await (const e of walkTree(entry)) {
         await processEntry(e, items)
       }
     } else {
       items.push(entry);
     }

     return items;
   }

   async function* walkTree(dir) {
     const reader = dir.createReader(),
       nextBatch = () => new Promise((resolve, reject) => reader.readEntries(resolve, reject));

     while (true) {
       let entries = await nextBatch();

       if (!entries.length) {
         break;
       }
       for (const entry of entries) {
         yield entry;
       }
     }
   }
 </script>
